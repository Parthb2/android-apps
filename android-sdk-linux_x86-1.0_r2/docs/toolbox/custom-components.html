






















































 








<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Building Custom Components</title>
<link rel="stylesheet" type="text/css" href="../assets/codesite/codesite.css" />
<link rel="stylesheet" type="text/css" href="../assets/codesite/codesearch.css" />
<link rel="stylesheet" type="text/css" href="../assets/codesite/semantic_headers.css" />
<link rel="stylesheet" type="text/css" href="../assets/style.css" />
<script src="../assets/search_autocomplete.js"></script>
<script src="../reference/lists.js"></script>
</head>

<body class="gc-documentation">
<div id="gc-container">
<a name="top"></a>

<div id="gc-header">
<div id="logo">
    <a href="http://code.google.com/android/"><img style="border: 0;" src="../assets-google/android-logo.gif"/></a>
</div> <!-- logo -->
</div> <!-- gc-header -->


<iframe id="backiFrame" name="backiFrame" style="display:none"></iframe>

<div id="codesiteContent" style="margin-top: 50px;">

<div id="gc-topnav">
    <span class="jd-toptitle">Android</span>
</div>

<div class="g-section g-tpl-180">

<a name="gc-toc-anchor"></a>  
<div class="g-unit g-first" id="gc-toc">
<div id="jd-searchbox" style="margin-top: 1px;">
    <input id="search_autocomplete"
            tabindex="1"
            autocomplete="off" type=text size="23"
            style="font-size:85%; color: #aaaaaa"
            value="(quick search)"
            onfocus="search_focus_changed(this, true)"
            onblur="search_focus_changed(this, false)"
            onkeydown="return search_changed(event, true, '../')"
            onkeyup="search_changed(event, false, '../')"
            onchange="search_changed(event, false, '../')"/>
    <div style="position: absolute;">
        <table id="search_filtered" class="jd-autocomplete-table-hidden"
                style="border: 1px solid #3366cc;"
                cellspacing=0>
        </table>
    </div>
</div>

<ul>
  <li>
    <h1><a href="../documentation.html">Documentation</a></h1>
    <ul>
      <li><a href="../what-is-android.html"><strong>What is Android?</strong></a></li>
      <li>
        <a href="../intro/index.html"><strong>Getting Started</strong></a>
        <ul>
          <li><a href="../intro/installing.html">Installing the SDK</a></li>
          <li><a href="../intro/upgrading.html">Upgrading the SDK</a></li>
          <li><a href="../intro/develop-and-debug.html">Developing/Debugging</a></li>
          <li><a href="../intro/hello-android.html">Hello Android</a></li>
          <li><a href="../intro/anatomy.html">Anatomy of an App</a></li>
          <li><a href="../intro/tutorial.html">Notepad Tutorial</a></li>
          <li><a href="../intro/tools.html">Development Tools</a></li>
          <li><a href="../intro/appmodel.html">Application Model</a></li>
          <li><a href="../intro/lifecycle.html">Application Life Cycle</a></li>
        </ul>
      </li>
      <li>
        <a href="../devel/index.html"><strong>Developing Applications</strong></a>
        <ul>
          <li><a href="../devel/implementing-ui.html">Implementing a UI</a></li>
          <li><a href="../devel/building-blocks.html">Building Blocks</a></li>
          <li><a href="../devel/data.html">Data Storage and Retrieval</a></li>
          <li><a href="../devel/security.html">Security Model</a></li>
          <li><a href="../devel/resources-i18n.html">Resources and i18n</a></li>
          <li><a href="../devel/sign-publish.html">Signing and Publishing Your App</a></li>
        </ul>
      </li>
      <li>  
        <a href="../toolbox/index.html"><strong>Developer Toolbox</strong></a>
        <ul>
          <li><a href="../toolbox/philosophy.html">Design Philosophy</a></li>
          <li><a href="../toolbox/custom-components.html">Building Custom Components</a></li>
          <li><a href="../toolbox/optional-apis.html">Optional APIs</a></li>
        </ul>
      </li>
      <li>  
        <a href="../reference/index.html"><strong>Reference Information</strong></a>
        <ul>
          <li><a href="../reference/packages.html">Package Index</a></li>
          <li><a href="../reference/classes.html">Class Index</a></li>
          <li><a href="../reference/hierarchy.html">Class Hierarchy</a></li>
          <li><a href="../reference/view-gallery.html">List of Views</a></li>
          <li><a href="../reference/available-intents.html">List of Intents</a></li>
          <li><a href="../reference/android/Manifest.permission.html">List of Permissions</a></li>
          <li><a href="../reference/available-resources.html">List of Resource Types</a></li>
          <li><a href="../reference/aidl.html">Android IDL</a></li>
          <li><a href="../reference/glossary.html">Glossary</a></li>
          <li><a href="../reference/keywords.html">Index</a></li>
        </ul>
      </li>
      
      <li>  
        <a href="../kb/index.html"><strong>FAQs</strong></a>
        <ul>
          <li><a href="../kb/general.html">General</a></li>
          <li><a href="../kb/commontasks.html">Common Tasks</a></li>
          <li><a href="../kb/troubleshooting.html">Troubleshooting</a></li>
          <li><a href="../kb/licensingandoss.html">Open Source Licensing</a></li>
	  <li><a href="../kb/framework.html">Application Framework</a></li>
	  <li><a href="../kb/security.html">Security</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h1><a href="../roadmap.html">Roadmap</a></h1>
  </li>
  <li>
    <h1><a href="../goodies/index.html">Goodies</a></h1>
  </li>
</ul>


</div>

<a name="gc-pagecontent-anchor"></a>   
<div class="g-unit" id="gc-pagecontent">


<div id="jd-content">

<div class="jd-descr">
<h1>Building Custom Android Components
</h1>
<p>
Android comes with a solid collection of View components that you can use
to construct your applications, e.g. 
<a href="../reference/android/widget/Button.html">Button</a>, 
<a href="../reference/android/widget/TextView.html">TextView</a>, 
<a href="../reference/android/widget/EditText.html">EditText</a>, 
<a href="../reference/android/widget/ListView.html">ListView</a>,
<a href="../reference/android/widget/CheckBox.html">CheckBox</a>, 
<a href="../reference/android/widget/RadioButton.html">RadioButton</a>, 
<a href="../reference/android/widget/Gallery.html">Gallery</a>, 
<a href="../reference/android/widget/Spinner.html">Spinner</a>, and even some much more advanced
and special purpose Views like 
<a href="../reference/android/widget/AutoCompleteTextView.html">AutoCompleteTextView</a>, 
<a href="../reference/android/widget/ImageSwitcher.html">ImageSwitcher</a>, and
<a href="../reference/android/widget/TextSwitcher.html">TextSwitcher</a>. The various layout 
managers like <a href="../reference/android/widget/LinearLayout.html">LinearLayout</a>, 
<a href="../reference/android/widget/FrameLayout.html">FrameLayout</a>,
and so forth are also considered Views and are descendents of the View class
hierarchy.</p>
<p>You can combine these layouts and controls into a screen to display in
your application, and much of the time this may be enough for you, but you
should also be aware that you can create custom components by extending Views, Layouts, and even the
advanced controls using inheritance.
Some typical reasons for doing this might include:</p>
 
<ul>
  <li>
    To create a completely custom-rendered component, for example a "volume
    control" knob rendered using 2D graphics, and which resembles an
    analog electronic control.
  </li>
  <li>
    Combine a group of View components into a new single component, perhaps
    to make something like a ComboBox (a combination of popup list and free
    entry text field), a dual-pane selector control (a left and right pane
    with a list in each where you can re-assign which item is in which
    list), and so on.
  </li>
  <li>
    To create your own kind of layout. The layouts provided in the SDK
    provide a good set of options for designing your own applications, but
    advanced developers may find the need to provide a new layout that extends
    one of the existing ones, or perhaps is entirely new.
  </li>
  <li>
    Override the display or behavior of an existing component; for example, 
    change the way that an EditText component is rendered on the screen
    (the Notepad sample uses this to good effect to create a lined-notepad
    page).
  </li>
  <li>
    Capture other events like key presses and handle them in some custom
    way (e.g. for a game).
  </li>
</ul>
<p>
 There are many more reasons why you might want to extend an existing View
to achieve some goal. This page will give you some starting points on how
to do it, and back it up with some examples.
</p>

<h2 style="clear:right;">Contents</h2>
<dl>
<dt><a href="#basic">The Basic Approach</a></dt>
<dt><a href="#custom">Fully Customized Components</a></dt>
<dt><a href="#customexample">Customized Component Example</a></dt>
<dt><a href="#compound">Compound Components (or Compound Controls)</a></dt>
<dt><a href="#tweaking">Tweaking an Existing Component</a></dt>
<dt><a href="#goforth">Go Forth and Componentize</a></dt>
</dl>

<a name="basic"></a> 
<h2>The Basic Approach
</h2>
<p>
These steps provide a high level overview of
what you need to know to get started in creating your own
components:</p>
 
<ol>
  <li>
    Extend an existing <a href="../reference/android/view/View.html">View</a> class or subclass 
	with your own class.
  </li>
  <li>
    Override some of the methods from the superclass: the superclass methods 
    to override start with '<code>on</code>', for
    example, <a href="../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a>, 
    <a href="../reference/android/view/View.html#onMeasure(int, int)">onMeasure()</a>, and 
    <a href="../reference/android/view/View.html#onKeyDown(int, android.view.KeyEvent)">onKeyDown()</a>.
    <ul>
      <li>
        This is similar to the <code>on...</code> events in <a href="../reference/android/app/Activity.html">Activity</a> or <a href="../reference/android/app/ListActivity.html">ListActivity</a>
        that you override for life cycle and other functionality hooks.
      </li>
    </ul>
  <li>
    Use your new extension class: once completed, your new extension class 
    can be used in place of the view upon which it was based, but now with the new 
    functionality.
  </li>
</ol>  
<p class="note">
    Extension classes can be defined as inner classes inside the activities
    that use them. This is useful because it controls access to them but
    isn't necessary (perhaps you want to create a new public component for
    wider use in your application).
</p>

<a name="custom"></a> 
<h2>Fully Customized Components</h2>
<p>
Fully customized components can be used to create graphical components that
appear however you wish. Perhaps a graphical VU
meter that looks like an old analog gauge, or a sing-a-long text view where
a bouncing ball moves along the words so you can sing along with a karaoke
machine. Either way, you want something that the built-in components just
won't do, no matter how you combine them.</p>
<p>Fortunately, you can easily create components that look and behave in any
way you like, limited perhaps only by your imagination, the size of the
screen, and the available processing power (remember that ultimately your
application might have to run on something with significantly less power
than your desktop workstation).</p>
<p>To create a fully customized component:</p> 
<ol>
  <li>
    The most generic view you can extend is, unsurprisingly, <a href="../reference/android/view/View.html">View</a>, so you will usually start by extending this to
    create your new super component.
  </li>
  <li>
    You can supply a constructor which can
    take attributes and parameters from the XML, and you can also consume
    your own such attributes and parameters (perhaps the color and range of
    the VU meter, or the width and damping of the needle, etc.)
  </li>
  <li>
    You will probably want to create your own event listeners,
    property accessors and modifiers, and possibly more sophisticated
    behavior in your component class as well.
  </li>
  <li>
    You will almost certainly want to override <code>onMeasure()</code> and
    are also likely to need to override <code>onDraw()</code> if you want
    the component to show something. While both have default behavior,
    the default <code>onDraw()</code> will do nothing, and the default
    <code>onMeasure()</code> will always set a size of 100x100 &mdash; which is
    probably not what you want.
  </li>
  <li>
    Other <code>on...</code> methods may also be overridden as required.
  </li>
</ol>
<h4><code>onDraw()</code> and <code>onMeasure()</code></h4>
<p><code>onDraw()</code> delivers you a <a href="../reference/android/graphics/Canvas.html">Canvas</a>
upon which you can implement anything you want: 2D graphics, other standard or
custom components, styled text, or anything else you can think of.</p>
<p><em>Note:</em>
Except for 3D graphics. If you want to
use 3D graphics, you must extend <a href="../reference/android/view/SurfaceView.html">SurfaceView</a>
instead of View, and draw from a seperate thread. See the
GLSurfaceViewActivity sample
for details.</p>
<p><code>onMeasure()</code> is a little more involved. <code>onMeasure()</code>
is a critical piece of the rendering contract between your component and its
container. <code>onMeasure()</code> should be overridden to efficiently and
accurately report the measurements of its contained parts. This is made
slightly more complex by the requirements of limits from the parent
(which are passed in to the <code>onMeasure()</code> method) and by the
requirement to call the <code>setMeasuredDimension()</code> method with the
measured width and height once they have been calculated. If you fail to
call this method from an overridden <code>onMeasure()</code> method, the 
result will be an exception at measurement time.</p>
<p>At a high level, implementing <code>onMeasure()</code> looks something 
 like this:</p>
 
<ol>
  <li>
    The overridden <code>onMeasure()</code> method is called with width and
    height measure specifications (<code>widthMeasureSpec</code> and
    <code>heighMeasureSpec</code> parameters, both are integer codes
    representing dimensions) which should be treated as requirements for
    the restrictions on the width and height measurements you should produce. A
    full reference to the kind of restrictions these specifications can require
    can be found in the reference documentation under <a href="../reference/android/view/View.html#onMeasure(int, int)">View.onMeasure(int, int)</a> (this reference
    documentation does a pretty good job of explaining the whole measurement
    operation as well).
  </li>
  <li>
    Your component's <code>onMeasure()</code> method should calculate a
    measurement width and height which will be required to render the
    component. It should try to stay within the specifications passed in,
    although it can choose to exceed them (in this case, the parent can
    choose what to do, including clipping, scrolling, throwing an exception, 
    or asking the <code>onMeasure()</code> to try again, perhaps with
    different measurement specifications).
  </li>
  <li>
    Once the width and height are calculated, the <code>setMeasuredDimension(int
    width, int height)</code> method must be called with the calculated
    measurements. Failure to do this will result in an exception being
    thrown.
  </li>
</ol>
 
<a name="customexample"></a>
<h3>A Customized Component Example</h3>
<p>The CustomView sample in the 
<a href="../samples/ApiDemos/index.html">API Demos</a> provides an example
of a customized component. The custom component is defined in the
<a href="../samples/ApiDemos/src/com/example/android/apis/view/LabelView.html">LabelView</a>
class.</p>
<p>The LabelView sample demonstrates a number of different aspects of custom components:</p>
<ul>
  <li>Extending the View class for a completely custom component.</li>
  <li>Parameterized constructor that takes the view inflation parameters
  (parameters defined in the XML). Some of these are passed through to the
  View superclass, but more importantly, there are some custom attributes defined
  and used for LabelView.</li>
  <li>Standard public methods of the type you would expect to see for a label
  component, for example <code>setText()</code>, <code>setTextSize()</code>,
  <code>setTextColor()</code> and so on.</li>
  <li>An overridden <code>onMeasure</code> method to determine and set the
  rendering size of the component. (Note that in LabelView, the real work is done
  by a private <code>measureWidth()</code> method.)</li>
  <li>An overridden <code>onDraw()</code> method to draw the label onto the
  provided canvas.</li>
</ul>
<p>You can see some sample usages of the LabelView custom component in
<a href="../samples/ApiDemos/res/layout/custom_view_1.html">custom_view_1.xml</a>
from the samples. In particular, you can see a mix of both <code>android:</code>
namespace parameters and custom <code>app:</code> namespace parameters. These
<code>app:</code> parameters are the custom ones that the LabelView recognizes
and works with, and are defined in a styleable inner class inside of the
samples R resources definition class.</p>

<a name="compound"></a>  
<h2>Compound Components (or Compound Controls)
</h2>
<p>If you don't want to create a completely customized component, but instead
are looking to put together a reusable component that consists of a group of
existing controls, then creating a Compound Component (or Compound Control) might
fit the bill. In a nutshell, this brings together a number of more atomic
controls (or views) into a logical group of items that can be treated as a
single thing. For example, a Combo Box can be thought of as a
combination of a single line EditText field and an adjacent button with an attached
 PopupList. If you press the button and select
something from the list, it populates the EditText field, but the user can
also type something directly into the EditText if they prefer.</p>
<p>In Android, there are actually two other Views readily available to do
this: <a href="../reference/android/widget/Spinner.html">Spinner</a> and 
<a href="../reference/android/widget/AutoCompleteTextView.html">AutoCompleteTextView</a>, but 
regardless, the concept of a Combo Box makes an easy-to-understand 
example.</p>
<p>To create a Compound Component:</p>
<ol>
  <li>
    The usual starting point is a Layout of some kind, so create a class
    that extends a Layout. Perhaps in the case of a Combo box we might use
    a LinearLayout with horizontal orientation. Remember that other layouts
    can be nested inside, so the compound component can be arbitrarily
    complex and structured. Note that just like with an Activity, you can
    use either the declarative (XML-based) approach to creating the
    contained components, or you can nest them programmatically from your
    code.
  </li>
  <li>
    In the constructor for the new class, take whatever parameters the
    superclass expects, and pass them through to the superclass constructor
    first. Then you can set up the other views to use within your new
    component; this is where you would create the EditText field and the
    PopupList. Note that you also might introduce your own attributes and
    parameters into the XML that can be pulled out and used by your
    constructor.
  </li>
  <li>
    You can also create listeners for events that your contained views might
    generate, for example, a listener method for the List Item Click Listener
    to update the contents of the EditText if a list selection is made.
  </li>
  <li>
    You might also create your own properties with accessors and modifiers,
    for example, allow the EditText value to be set initially in the
    component and query for its contents when needed.
  </li>
  <li>
    In the case of extending a Layout, you don't need to override the
    <code>onDraw()</code> and <code>onMeasure()</code> methods since the
    layout will have default behavior that will likely work just fine. However, 
    you can still override them if you need to.
  </li>
  <li>
    You might override other <code>on...</code> methods, like
    <code>onKeyDown()</code>, to perhaps choose certain default values from
    the popup list of a combo box when a certain key is pressed.
  </li>
</ol>
<p>
 To summarize, the use of a Layout as the basis for a Custom Control has a
number of advantages, including:</p>
 
<ul>
  <li>
    You can specify the layout using the declarative XML files just like
    with an activity screen, or you can create views programmatically and
    nest them into the layout from your code.
  </li>
  <li>
    The <code>onDraw()</code> and <code>onMeasure()</code> methods (plus
    most of the other <code>on...</code> methods) will likely have suitable behavior so
    you don't have to override them.
  </li>
  <li>
    In the end, you can very quickly construct arbitrarily complex compound
    views and re-use them as if they were a single component.
  </li>
</ul>
<h4>Examples of Compound Controls</h4>
<p>In the API Demos project
 that comes with the SDK, there are two List
 examples &mdash; Example 4 and Example 6 under Views/Lists demonstrate a
 SpeechView which extends LinearLayout to make a component for displaying
 Speech quotes. The corresponding classes in the sample code are
 <code>List4.java</code> and <code>List6.java</code>.</p>
 
<a name="tweaking"></a>  
<h2>Tweaking an Existing Component
</h2>
<p>There is an even easier option for creating a custom component which is
useful in certain circumstances. If there is a component that is already very
similar to what you want, you can simply extend that component and just
override the behavior that you want to change. You can do all of the things
you would do with a fully customized component, but by starting with a more
specialized class in the View heirarchy, you can also get a lot of behavior for
free that probably does exactly what you want.</p>
<p>For example, the SDK includes a <a
href="../samples/NotePad/index.html">NotePad application</a> in the
samples. This demonstrates many aspects of using the Android platform, among
them is extending an EditText View to make a lined notepad. This is not a
perfect example, and the APIs for doing this might change from this early
preview, but it does demonstrate the principles.</p>
<p>If you haven't done so already, import the 
NotePad sample into Eclipse (or
just look at the source using the link provided). In particular look at the definition of
<code>MyEditText</code> in the <a
href="../samples/NotePad/src/com/example/android/notepad/NoteEditor.html">NoteEditor.java</a>
file.</p>
<p>Some points to note here</p>
<ol>
  <li>
    <strong>The Definition</strong>
    <p>The class is defined with the following line:</p>
     <code>public static class MyEditText extends EditText</code><br><br>
     
    <ul>
      <li>
        It is defined as an inner class within the <code>NoteEditor</code>
        activity, but it is public so that it could be accessed as
        <code>NoteEditor.MyEditText</code> from outside of the <code>NoteEditor</code>
        class if desired.
      </li>
      <li>
        It is <code>static</code>, meaning it does not generate the so-called
        "synthetic methods" that allow it to access data from the parent
        class, which in turn means that it really behaves as a separate
        class rather than something strongly related to <code>NoteEditor</code>.
        This is a cleaner way to create inner classes if they do not need
        access to state from the outer class, keeps the generated class
        small, and allows it to be used easily from other classes.
      </li>
      <li>
        It extends <code>EditText</code>, which is the View we have chosen to
        customize in this case. When we are finished, the new class will be
        able to substitute for a normal <code>EditText</code> view.<br>
        <br>
      </li>
    </ul>
  </li>
  <li>
    <strong>Class Initialization</strong>
    <p>As always, the super is called first. Furthermore, 
    this is not a default constructor, but a parameterized one. The
    EditText is created with these parameters when it is inflated from an
    XML layout file, thus, our constructor needs to both take them and pass them
    to the superclass constructor as well.</p>
  </li>
  <li>
    <strong>Overridden Methods</strong>
    <p>In this example, there is only one method to be overridden: 
    <code>onDraw()</code> &mdash; but there could easily be others needed when you
    create your own custom components.</p>
    <p>For the NotePad sample, overriding the <code>onDraw()</code> method allows
    us to paint the blue lines on the <code>EditText</code> view canvas (the
    canvas is passed into the overridden <code>onDraw()</code> method). The
    super.onDraw() method is called before the method ends. The
    superclass method should be invoked, but in this case, we do it at the
    end after we have painted the lines we want to include.</p>
  <li>
    <strong>Use the Custom Component</strong>
    <p>We now have our custom component, but how can we use it? In the
    NotePad example, the custom component is used directly from the
    declarative layout, so take a look at <code>note_editor.xml</code> in the
    <code>res/layout</code> folder.</p>
    <pre>
&lt;view xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; 
  class=&quot;com.android.notepad.NoteEditor$MyEditText&quot; 
  id=&quot;&#64;+id/note&quot;
  android:layout_width=&quot;fill_parent&quot;
  android:layout_height=&quot;fill_parent&quot;
  android:background=&quot;&#64;android:drawable/empty&quot;
  android:padding=&quot;10dip&quot;
  android:scrollbars=&quot;vertical&quot;
  android:fadingEdge=&quot;vertical&quot; /&gt; </pre>
     
    <ul>
      <li>
        The custom component is created as a generic view in the XML, and
        the class is specified using the full package. Note also that the
        inner class we defined is referenced using the
        <code>NoteEditor$MyEditText</code> notation which is a standard way to
        refer to inner classes in the Java programming language.
      </li>
      <li>
        The other attributes and parameters in the definition are the ones
        passed into the custom component constructor, and then passed
        through to the EditText constructor, so they are the same
        parameters that you would use for an EditText view. Note that it is
        possible to add your own parameters as well, and we will touch on
        this again below.
      </li>
    </ul>
  </li>
</ol>
<p>And that's all there is to it. Admittedly this is a simple case, but
that's the point &mdash; creating custom components is only as complicated as you
need it to be.</p>
<p>A more sophisticated component may override even more <code>on...</code> methods and
introduce some of its own helper methods, substantially customizing its properties and
behavior. The only limit is your imagination and what you need the component to
do.</p>
<a name="goforth"></a> 
<h2>Go Forth and Componentize
</h2>
<p>
As you can see, Android offers a sophisticated and powerful component model
where just about anything is possible, from simple tweaking of existing
Views, to compound controls, to fully customized components. Combining these techniques,
you should be able to achieve the exact look you want for your Android
application. 
</p>

</div>

</div>
</div><!-- end gc-pagecontent -->
</div><!-- end gooey wrapper -->

<div style="padding-left: 10px; padding-right: 10px; margin-top: 0; padding-bottom: 15px;">
    <table style="width: 100%; border:none;"><tr>
    <td style="border: none; width: 150px;"></td>
    <td style="text-align: left; font-size: 10pt; border: none; color: silver;">Copyright 2007 <a href="http://labs.google.com/">Google Inc.</a></td>
    <td style="text-align: right; font-size: 10pt; border: none; color: silver;">Build 119366-119366 - 19 Nov 2008 16:04</td>
    </tr></table>
</div>


</body>

</html>


