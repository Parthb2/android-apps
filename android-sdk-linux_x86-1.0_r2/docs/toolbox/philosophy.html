






















































 








<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Application Design Philosophy</title>
<link rel="stylesheet" type="text/css" href="../assets/codesite/codesite.css" />
<link rel="stylesheet" type="text/css" href="../assets/codesite/codesearch.css" />
<link rel="stylesheet" type="text/css" href="../assets/codesite/semantic_headers.css" />
<link rel="stylesheet" type="text/css" href="../assets/style.css" />
<script src="../assets/search_autocomplete.js"></script>
<script src="../reference/lists.js"></script>
</head>

<body class="gc-documentation">
<div id="gc-container">
<a name="top"></a>

<div id="gc-header">
<div id="logo">
    <a href="http://code.google.com/android/"><img style="border: 0;" src="../assets-google/android-logo.gif"/></a>
</div> <!-- logo -->
</div> <!-- gc-header -->


<iframe id="backiFrame" name="backiFrame" style="display:none"></iframe>

<div id="codesiteContent" style="margin-top: 50px;">

<div id="gc-topnav">
    <span class="jd-toptitle">Android</span>
</div>

<div class="g-section g-tpl-180">

<a name="gc-toc-anchor"></a>  
<div class="g-unit g-first" id="gc-toc">
<div id="jd-searchbox" style="margin-top: 1px;">
    <input id="search_autocomplete"
            tabindex="1"
            autocomplete="off" type=text size="23"
            style="font-size:85%; color: #aaaaaa"
            value="(quick search)"
            onfocus="search_focus_changed(this, true)"
            onblur="search_focus_changed(this, false)"
            onkeydown="return search_changed(event, true, '../')"
            onkeyup="search_changed(event, false, '../')"
            onchange="search_changed(event, false, '../')"/>
    <div style="position: absolute;">
        <table id="search_filtered" class="jd-autocomplete-table-hidden"
                style="border: 1px solid #3366cc;"
                cellspacing=0>
        </table>
    </div>
</div>

<ul>
  <li>
    <h1><a href="../documentation.html">Documentation</a></h1>
    <ul>
      <li><a href="../what-is-android.html"><strong>What is Android?</strong></a></li>
      <li>
        <a href="../intro/index.html"><strong>Getting Started</strong></a>
        <ul>
          <li><a href="../intro/installing.html">Installing the SDK</a></li>
          <li><a href="../intro/upgrading.html">Upgrading the SDK</a></li>
          <li><a href="../intro/develop-and-debug.html">Developing/Debugging</a></li>
          <li><a href="../intro/hello-android.html">Hello Android</a></li>
          <li><a href="../intro/anatomy.html">Anatomy of an App</a></li>
          <li><a href="../intro/tutorial.html">Notepad Tutorial</a></li>
          <li><a href="../intro/tools.html">Development Tools</a></li>
          <li><a href="../intro/appmodel.html">Application Model</a></li>
          <li><a href="../intro/lifecycle.html">Application Life Cycle</a></li>
        </ul>
      </li>
      <li>
        <a href="../devel/index.html"><strong>Developing Applications</strong></a>
        <ul>
          <li><a href="../devel/implementing-ui.html">Implementing a UI</a></li>
          <li><a href="../devel/building-blocks.html">Building Blocks</a></li>
          <li><a href="../devel/data.html">Data Storage and Retrieval</a></li>
          <li><a href="../devel/security.html">Security Model</a></li>
          <li><a href="../devel/resources-i18n.html">Resources and i18n</a></li>
          <li><a href="../devel/sign-publish.html">Signing and Publishing Your App</a></li>
        </ul>
      </li>
      <li>  
        <a href="../toolbox/index.html"><strong>Developer Toolbox</strong></a>
        <ul>
          <li><a href="../toolbox/philosophy.html">Design Philosophy</a></li>
          <li><a href="../toolbox/custom-components.html">Building Custom Components</a></li>
          <li><a href="../toolbox/optional-apis.html">Optional APIs</a></li>
        </ul>
      </li>
      <li>  
        <a href="../reference/index.html"><strong>Reference Information</strong></a>
        <ul>
          <li><a href="../reference/packages.html">Package Index</a></li>
          <li><a href="../reference/classes.html">Class Index</a></li>
          <li><a href="../reference/hierarchy.html">Class Hierarchy</a></li>
          <li><a href="../reference/view-gallery.html">List of Views</a></li>
          <li><a href="../reference/available-intents.html">List of Intents</a></li>
          <li><a href="../reference/android/Manifest.permission.html">List of Permissions</a></li>
          <li><a href="../reference/available-resources.html">List of Resource Types</a></li>
          <li><a href="../reference/aidl.html">Android IDL</a></li>
          <li><a href="../reference/glossary.html">Glossary</a></li>
          <li><a href="../reference/keywords.html">Index</a></li>
        </ul>
      </li>
      
      <li>  
        <a href="../kb/index.html"><strong>FAQs</strong></a>
        <ul>
          <li><a href="../kb/general.html">General</a></li>
          <li><a href="../kb/commontasks.html">Common Tasks</a></li>
          <li><a href="../kb/troubleshooting.html">Troubleshooting</a></li>
          <li><a href="../kb/licensingandoss.html">Open Source Licensing</a></li>
	  <li><a href="../kb/framework.html">Application Framework</a></li>
	  <li><a href="../kb/security.html">Security</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h1><a href="../roadmap.html">Roadmap</a></h1>
  </li>
  <li>
    <h1><a href="../goodies/index.html">Goodies</a></h1>
  </li>
</ul>


</div>

<a name="gc-pagecontent-anchor"></a>   
<div class="g-unit" id="gc-pagecontent">


<div id="jd-content">

<div class="jd-descr">
<h1> Android Application Design Philosophy</h1>
<p>The process of learning how to build applications for a new API is pretty
similar, even if the platforms themselves are wildly different. Generally,
there are two phases: first, you learn how to use the APIs to do what you
want to do; later, you learn the nuances of the platform. Put
another way, first you learn how you <em>can</em> build applications; later, you
learn how you <em>should</em> build them.</p>

<p>That second phase &mdash; learning the right way to build applications &mdash; can often
take a long time, and frequently means "paying your dues", making mistakes, and
learning from them. Well, that's not a very efficient process, so this
page and the links below aim to give you a helping hand.</p>

<p>Before we dive into it, a quick word. Successful applications will offer an outstanding 
end-user experience. While the Android team has built a robust core system, the vast majority 
of the user experience will come from users interacting with your applications. As a result, 
we encourage you to take the time to build an outstanding user experience.</p>

<p>An outstanding user experience has three key characteristics: it is
<em>fast</em>; it is <em>responsive</em>; and it is <em>seamless</em>. Of course
every platform since the dawn of computing has probably cited those same three
qualities at one time or another. However, each platform achieves them in
different ways; the information below explains how your apps can achieve
them on Android.</p>

<h2>Fast</h2>
<p>An Android application should be fast. Well, it's probably more accurate to
say that it should be <em>efficient</em>. There is a tendency in the
computing world these days to assume that Moore's Law will solve all our
problems &mdash; eventually. When it comes to embedded applications, though,
Moore's Law is a bit more complicated.</p>

<p>Moore's Law doesn't really apply to mobile devices in the same way as to desktop
and server applications. Moore's Law is actually a law about transistor
density &mdash; that is, it says that you can pack more circuitry into a given chip
size, over time. For desktop and server applications, this means you can
pack more "speed" into a chip of roughly the same size, resulting in the
well-known performance increases. For embedded applications like cell
phones, however, Moore's Law is usually exploited to make chips
<em>smaller</em>. That is, the tendency is to use the increased density to
make the same chip smaller and consume less power, to make phones smaller and
make batteries last longer. As a result, embedded devices like phones are
increasing in actual, raw speed much more slowly than desktop systems. For
embedded devices, Moore's Law means more features and better battery life;
increased speed is only an afterthought.</p>

<p>That's why it's important to write efficient code: you can't
assume that phones will see the same speed increases as desktops and
servers. Generally speaking, writing fast code means keeping memory
allocations to a minimum, writing tight code, and avoiding certain language and
programming idioms that can subtly cripple performance. In object-oriented
terms, most of this work takes place at the <em>method</em> level, on the order of
actual lines of code, loops, and so on.</p>

<p>The article on
<a href="../toolbox/performance.html" title="Writing Performant Android Code">Writing
Efficient Android Code</a> will give you all the detail you need to write fast,
efficient code for Android.</p>

<h2>Responsive</h2>
<p>It's possible to write code that wins every performance test in the world, but
that still sends users in a fiery rage when they try to use it. These are
the applications that aren't <em>responsive</em> enough &mdash; the ones that feel
sluggish, hang or freeze for significant periods, or take too long to process
input. In Android terms, applications that are insufficiently responsive
will frequently cause the system to pop up the dreaded "Application Not
Responding" (ANR) message.</p>

<p>Generally, this happens if your application cannot respond to user input.
For example, if your application blocks on some I/O operation (frequently a
network access), then the main application thread won't be able to process
incoming user input events. After a time the system will conclude that
your application has hung, and give the user the option to kill it. Similarly,
if your application spends too much time building an elaborate in-memory
structure, or perhaps computing the next move in a game, then again the system
will conclude that your application has hung. It's always important to make
sure these computations are efficient using the techniques above, but even the
most efficient code still takes time to run.</p>

<p>In both of these cases, the fix is usually to create a child thread, and do
most of your work there. This keeps the main thread (which drives the user
interface event loop) running, and prevents the system from concluding your code
has frozen. Since such threading usually is accomplished at the class
level, you can think of responsiveness as a <em>class</em> problem. (Compare
this with basic performance, which was described above as a <em>method</em>-level
concern.)</p>

<p>The article on
<a href="../toolbox/responsiveness.html" id="sh43" title='Preventing "Application Not Responding" Warnings'>Building
Responsive Android Applications</a> discusses responsiveness in detail.</p>

<h2>Seamless</h2>
<p>Even if your application is fast and responsive, it can still annoy users.
A common example is a background process (such as an Android
<a href="../reference/android/app/Service.html">Service</a>
or
<a href="../reference/android/content/Intent.html">BroadcastReceiver</a>)
that pops up a UI in response to some event. This may seem harmless, and
frequently developers assume that this is okay because they spend most of their
time testing and using their own application. However, Android's
application model is constructed explicitly to allow users to fluidly switch
between applications. This means that when your background process
actually fires up that UI, the user could be way over in another part of the
system, doing something else &mdash; such as taking a phone call. Imagine if
the SMS service popped up a dialog box every time a text message came in;
this would annoy users in no time. That's why the Android standard is to
use Notifications for such events; this leaves the user in control.</p>

<p>That's just one example; there are many more. For example, if
Activities don't correctly implement the onPause() and other life-cycle methods,
this will frequently result in data loss. Or, if your application exposes
data intended to be used by other applications, you should expose it via a
ContentProvider, rather than (for example) using a world-readable raw file or
database.</p>

<p>What those examples have in common is that they involve cooperating nicely with
the system and other applications. The Android system is designed to treat
applications as a sort of federation of loosely-coupled components, rather than
chunks of black-box code. This allows you as the developer to view the
entire system as just an even-larger federation of these components. This
benefits you by allowing you to integrate cleanly and seamlessly with other
applications, and so you should design your own code to return the favor.</p>

<p>This is a <em>component</em>-level concept (as opposed to the <em>class</em>- and
<em>method</em>-level concepts of performance and responsiveness, described
above.) The article on
<a href="../toolbox/seamlessness.html" id="w6nb" title="Working with the System">Integrating
with the System</a> provides tips and best practices for writing code that
cooperates nicely with the rest of the system.</p>

</div>

</div>
</div><!-- end gc-pagecontent -->
</div><!-- end gooey wrapper -->

<div style="padding-left: 10px; padding-right: 10px; margin-top: 0; padding-bottom: 15px;">
    <table style="width: 100%; border:none;"><tr>
    <td style="border: none; width: 150px;"></td>
    <td style="text-align: left; font-size: 10pt; border: none; color: silver;">Copyright 2007 <a href="http://labs.google.com/">Google Inc.</a></td>
    <td style="text-align: right; font-size: 10pt; border: none; color: silver;">Build 119366-119366 - 19 Nov 2008 16:04</td>
    </tr></table>
</div>


</body>

</html>


